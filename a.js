//1)
//if (!("a" in window)) {
//    var a = 1;
//}
//alert(a);

/* undefined возвращается по той причине, что переменная декларируется вне зависимости от того, где ей присвоено значение, и делает это в начале выполнения скрипта. Соответственно, раз она уже задекларирована, то она есть в объекте window, а значит факт нахождения в глобальном объекте свойства a в противоположном значении вернет false. Таким образом, условие не выполнится и a останется со своим первоначальным значением - undefined*/

//2)
//var b = function a(x) {
//    x && a(--x);
//};
//alert(a);

/* ошибка "a not defined" возвращается по той причине, что переменной или функции с именем "a" нет. Есть только именованное функциональное выражение*/

//3)
//function a(x) {
//    return x * 2;
//}
//var a;
//alert(a);

/* в отличие от п.2, здесь задекларирована именно функция под именем а, поэтому в alerte показывается ее тело*/

//4)
//function b(x, y, a) {
//    arguments[2] = 10;
//    alert(a);
//}
//b(1, 2, 3);

/*4) 10, т. к. изначально 3-й элемент псевдомассива принимал аргумент с именем "a", а мы в функции переназначили вместо этого число 10, т. е. теперь при дальнейших вызовах "а" ни на что не влияет*/

//5)
//function a() {
//    alert(this);
//}
//a.call(null);

/*5) [object Window] - тут не остается других вариантов, т.к. call работает как this, но объектов, к которым можно было бы обратиться, нет, вместо него - "пустой" null, поэтому остается только global object. Если вместо null подставить this или window, результат не поменяется */